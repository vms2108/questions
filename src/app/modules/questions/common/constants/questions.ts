import { SectionEnum } from './../../../../common/enums/section.enum';
import { ComplexityEnum } from './../../../../common/enums/complexity.enum';
import { QuestionOld } from 'src/app/common/models/question-old';

export const QUESTIONS: QuestionOld[] = [
  new QuestionOld(
    'Метод OPTIONS',
    `Используется для определения возможностей веб-сервера или параметров соединения для конкретного ресурса. В ответ серверу следует включить заголовок Allow со списком поддерживаемых методов. Также в заголовке ответа может включаться информация о поддерживаемых расширениях.
    <br><br>
    Предполагается, что запрос клиента может содержать тело сообщения для указания интересующих его сведений. Формат тела и порядок работы с ним в настоящий момент не определён; сервер пока должен его игнорировать. Аналогичная ситуация и с телом в ответе сервера.`,
    ComplexityEnum.JUNIOR,
    SectionEnum.COMMON,
    ),
  new QuestionOld(
    'Метод GET',
    `Используется для запроса содержимого указанного ресурса. С помощью метода GET можно также начать какой-либо процесс. В этом случае в тело ответного сообщения следует включить информацию о ходе выполнения процесса.
    <br><br>
    Клиент может передавать параметры выполнения запроса в URI целевого ресурса после символа «?»`,
    ComplexityEnum.JUNIOR,
    SectionEnum.COMMON,
  ),
  new QuestionOld(
    'Метод HEAD',
    `Аналогичен методу GET, за исключением того, что в ответе сервера отсутствует тело. Запрос HEAD обычно применяется для извлечения метаданных, проверки наличия ресурса (валидация URL) и чтобы узнать, не изменился ли он с момента последнего обращения.`,
    ComplexityEnum.JUNIOR,
    SectionEnum.COMMON,
    ),
  new QuestionOld(
    'Метод POST',
    `Применяется для передачи пользовательских данных заданному ресурсу. При этом передаваемые данные включаются в тело запроса.
    <br><br>
    В отличие от метода GET, метод POST не считается идемпотентным[2], то есть многократное повторение одних и тех же запросов POST может возвращать разные результаты (например, после каждой отправки комментария будет появляться очередная копия этого комментария).`,
    ComplexityEnum.JUNIOR,
    SectionEnum.COMMON,
    ),
  new QuestionOld(
    'Метод PUT',
    `Применяется для загрузки содержимого запроса на указанный в запросе URI.
    <br><br>
    Фундаментальное различие методов POST и PUT заключается в понимании предназначений URI ресурсов. Метод POST предполагает, что по указанному URI будет производиться обработка передаваемого клиентом содержимого. Используя PUT, клиент предполагает, что загружаемое содержимое соответствует находящемуся по данному URI ресурсу.`,
    ComplexityEnum.JUNIOR,
    SectionEnum.COMMON,
    ),

  new QuestionOld(
    'Какие версии HTTP-протокола вам известны?',
    `1. Стандарт HTTP/0.9 – версия протокола HTTP 0.9 была разработана в 1991 году в ЦЕРН Тимом Бернерсом-Ли. Тим разработал HTTP протокол для облегчения доступа и создания навигации при помощи гипертекста. Протокол версии 0.9 был призван упорядочить взаимодействие между клиентом и сервером в сети. После появления стандарта HTTP/0.9 появилось разделение функций между клиентом и сервером при их взаимодействии.
    <br><br>
    2. В 1996 году был выпущен информационный документ RFC 1945 (стандарт HTTP/1.0). Данный документ стал основой для реализации приложений и компонентов с использованием протокола HTTP версии 1.0.
    <br><br>
    3. В 1997 году была выпущена версия протокола HTTP1: был разработан стандарт HTTP/1.1 и описан он в документе RFC 2068.
    В 1999 году был доработан стандарт HTTP/1.1 (именно стандарт HTTP/1.1).
    Доработки коснулись: общего дизайна стандарта, формулировки и разъяснения некоторых терминов, исправлены опечатки,
    даны некоторые разъяснения по взаимодействию клиента и HTTP сервера в спорных ситуациях.
    Основным нововведением в версию протокола HTTP 1.1 был режим постоянного соединения, другими словами:
    за одно соединение можно было отправлять несколько HTTP запросов и получать несколько HTTP ответов в том порядке,
    в котором делались запросы.
    Вторым основным нововведение в версию протокола HTTP 1.1 является то,
    что теперь клиент при установке соединения с сервером должен обязательно посылать имя хоста в специальном поле HTTP заголовка
    (данное нововведение привело к массовому распространению виртуальных хостингов).
    На данный момент большинство приложений для своей работы используют HTTP протокол версии 1.1.
    Стоит заметить, что версия HTTP протокола является очень важным HTTP параметром, который должны использовать все приложения.
    `,
    ComplexityEnum.JUNIOR,
    SectionEnum.COMMON,
  ),
  new QuestionOld(
    'Что такое Cross-Origin Resource Sharing? Как устранить проблемы с CORS?',
    `Механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент. <br><br> реализовать проксирование или добавить в header ответа сервера нужные заголовки`,
    ComplexityEnum.JUNIOR,
    SectionEnum.COMMON,
  ),
  new QuestionOld(
    'Что такое cookie?',
    `Это хранящиеся на компьютерах и гаджетах небольшие файлы, c помощью которых сайт запоминает информацию о посещениях пользователя.`,
    ComplexityEnum.JUNIOR,
    SectionEnum.COMMON,
  ),
  new QuestionOld(
    'Какой максимальный размер cookie?',
    `Так, браузер должен хранить по меньшей мере 300 cookie по 4096 байт каждая, и по меньшей мере 20 cookie для одного сервера или домена.
    Популярные браузеры имеют соответствующий максимум хранящихся cookie для каждого домена:
    Firefox 2.0 — 50
    Google Chrome 58.0 — 176
    Safari 10.0 — 242`,
    ComplexityEnum.JUNIOR,
    SectionEnum.COMMON,
  ),
  new QuestionOld(
    'Что означает директива use strict?',
    `"use strict"; (перевод: «использовать строгий») - это установка, которая заставляет код обрабатываться в строгом режиме. Без этой установки код обрабатывается в неограниченном режиме.
    <br><br>
    Строгий режим был введён в ECMAScript 5, и старые браузеры (IE9 и младше) его не поддерживают`,
    ComplexityEnum.JUNIOR,
    SectionEnum.COMMON,
  ),
  new QuestionOld(
    'Чем JS отличается при работе на front-end и back-end?',
    `Сам JS не отличаются. Есть различия в используемых библиотеках, фреймворках`,
    ComplexityEnum.JUNIOR,
    SectionEnum.COMMON,
  ),
  new QuestionOld(
    'Что такое статическая и динамическая типизации?',
    `Статически типизированные языки ограничивают типы переменных: язык программирования может знать, например, что x — это Integer. В этом случае программисту запрещается делать x = true. Статические языки проверяют типы в программе во время компиляции, еще до запуска программы.`,
    ComplexityEnum.JUNIOR,
    SectionEnum.COMMON,
  ),
  new QuestionOld(
    'Как клиент взаимодействует с сервером?',
    `Веб-браузеры взаимодействуют с веб-серверами при помощи протокола передачи гипертекста (HTTP). Когда вы кликаете на ссылку на странице, заполняете форму или производите поиск, браузер отправляет на сервер HTTP-запрос.`,
    ComplexityEnum.JUNIOR,
    SectionEnum.COMMON,
  ),
  new QuestionOld(
    'Что такое REST?',
    `HTTP - протокол, а REST - стиль архитектуры для построения веб служб, интерфейс управления информацией. Каждая единица информации однозначно определяется глобальным идентификатором, таким как URL. Каждая URL в свою очередь имеет строго заданный формат.`,
    ComplexityEnum.JUNIOR,
    SectionEnum.COMMON,
  ),
  new QuestionOld(
    'Объяснить понятие мутабельность/иммутабельность? Какие типы являются мутабельными и наоборот?',
    `Неизменяемым (англ. immutable) называется объект, состояние которого не может быть изменено после создания. Результатом любой модификации такого объекта всегда будет новый объект, при этом старый объект не изменится.
    <br><br>
    Все типы данных в JavaScript, кроме объектов, являются иммутабельными (значения не могут быть модифицированы, а только перезаписаны новым полным значением)`,
    ComplexityEnum.JUNIOR,
    SectionEnum.COMMON,
  ),
  new QuestionOld(
    'Как искать ошибки в коде? Используете ли вы дебаггер?',
    `Обычно отслеживаю ошибки в консоли. Использую console.log. Кроме того настраиваем логгирование ошибок на сервер.
    То есть на фронте можно реализовать обработчик ошибок с отправкой в aws. А там можно отслеживать и смотреть, что за ошибки возникают у реальных пользователей и как часто`,
    ComplexityEnum.JUNIOR,
    SectionEnum.COMMON,
  ),
  new QuestionOld(
    'Какие существуют типы данных в JS?',
    `Стандарт ECMAScript определяет 8 типов:<br>

    6 типов данных являющихся примитивами:<br>
    Undefined (Неопределённый тип) : typeof instance === "undefined"<br>
    Boolean (Булев, Логический тип) : typeof instance === "boolean"<br>
    Number (Число) : typeof instance === "number"<br>
    String (Строка) : typeof instance === "string"<br>
    BigInt : typeof instance === "bigint"<br>
    Symbol (в ECMAScript 6) : typeof instance === "symbol"<br><br>
    Null (Null тип ) : typeof instance === "object". Специальный примитив, используемый не только для данных, но и в качестве указателя на финальную точку в Цепочке Прототипов;<br>
    Object (Объект) : typeof instance === "object". Простая структура, используемая не только для хранения данных, но и для создания других структур, где любая структура создаётся с использованием ключевого слова new: new Object, new Array, new Map (en-US), new Set, new WeakMap, new WeakSet, new Date и множество других структур;`,
    ComplexityEnum.JUNIOR,
    SectionEnum.JS_CORE,
  ),
  new QuestionOld(
    'Как проверить, является ли объект массивом?',
    `Array.isArray()`,
    ComplexityEnum.JUNIOR,
    SectionEnum.JS_CORE,
  ),
  new QuestionOld(
    'Как проверить, является ли число конечным?',
    `Number.isFinite() определяет, является ли значение конечным числом. Возвращает false, если аргумент является NaN, положительной или отрицательной бесконечностью (Infinity или -Infinity). Иначе возвращает true.`,
    ComplexityEnum.JUNIOR,
    SectionEnum.JS_CORE,
  ),
  new QuestionOld(
    'Чем отличается поведение isNaN() и Number.isNaN()?',
    `Number.isNaN () отличается от глобальной функции isNaN(). Глобальная функция isNaN() преобразует тестируемое значение в число, а затем проверяет его.
    Number.isNaN() не преобразует значения в число и не возвращает true для любого значения, которое не относится к типу Number.`,
    ComplexityEnum.JUNIOR,
    SectionEnum.JS_CORE,
  ),
  new QuestionOld(
    'Сравните ключевые слова var, let, const',
    `var:<br>
    function scoped<br>
    undefined when accessing a variable before it's declared<br><br>
  let: <br>
    block scoped<br>
    ReferenceError when accessing a variable before it's declared<br><br>
  const:<br>
    block scoped<br>
    ReferenceError when accessing a variable before it's declared<br>
    can't be reassigned`,
    ComplexityEnum.JUNIOR,
    SectionEnum.JS_CORE,
  ),
  new QuestionOld(
    'Что такое область видимости?',
    `Область видимости определяет доступность переменных. Переменная, объявленная в текущей области видимости, доступна только внутри нее.
    <br><br>
    В JavaScript области видимости создаются блоками, функциями и модулями.
    <br><br>
    Переменные, объявленные с помощью ключевых слова const и let могут иметь блочную, функциональную или модульную область видимости, а переменные, объявленные с помощью ключевого слова var, не имеют блочной области видимости.
    <br><br>
    Области видимости могут быть вложенными. Переменные, объявленные во внешней области видимости, доступны во внутренней области.
    <br><br>
    Лексическая область видимости состоит из внешних областей, определенных статически. Любая функция, независимо от места выполнения, имеет доступ к переменным из ее лексической области видимости (в этом заключается суть замыканий).`,
    ComplexityEnum.JUNIOR,
    SectionEnum.JS_CORE,
  ),
  new QuestionOld(
    'Что такое деструктуризация?',
    `Деструктуризация (destructuring) – синтаксическая возможность "раскладывать" элементы массива (и не только) в отдельные константы или переменные.`,
    ComplexityEnum.JUNIOR,
    SectionEnum.JS_CORE,
  ),
  new QuestionOld(
    'Для чего предназначены методы setTimeout и setInterval?',
    `setTimeout позволяет вызвать функцию один раз через определённый интервал времени. setInterval позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.`,
    ComplexityEnum.JUNIOR,
    SectionEnum.JS_CORE,
  ),
  new QuestionOld(
    'Сравните подходы работы с асинхронным кодом: сallbacks vs promises vs async / await',
    `Это дело вкуса. Цепочки коллбэков могут показаться сложными. Поэтому их принято заменять на цепочки промисов. А цепочки промисов можно заменить на последовательный вызов await`,
    ComplexityEnum.JUNIOR,
    SectionEnum.JS_CORE,
  ),
  new QuestionOld(
    'Что такое прототип?',
    `Это «резервное хранилище свойств и методов» объекта, автоматически используемое при поиске. <br> <br>
    JavaScript часто описывают как язык прототипного наследования — каждый объект, имеет объект-прототип, который выступает как шаблон, от которого объект наследует методы и свойства. Объект-прототип так же может иметь свой прототип и наследовать его свойства и методы и так далее. Это часто называется цепочкой прототипов`,
    ComplexityEnum.JUNIOR,
    SectionEnum.JS_CORE,
  ),
  new QuestionOld(
    'Какие методы массива вы знаете?',
    `push - вставка в конец, unshift - вставка в начало, find - поиск, останавливается при первом true,
    filter - фильтрует, если true, map - возвращает новый массив, sort - сортирует, reverse - меняет порядок на противоположный,
    split/join - преобразует строку в массив и обратно,
    reduce/reduceRight(func, initial),
    indexOf/lastIndexOf(item, pos) – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено,
    pop() – извлекает элемент с конца,
    shift() – извлекает элемент с начала,
    forEach`,
    ComplexityEnum.JUNIOR,
    SectionEnum.JS_CORE,
  ),
  new QuestionOld(
    'Методы перебора массива',
    `forEach – для перебора массива.<br>
    filter – для фильтрации массива.<br>
    every/some – для проверки массива.<br>
    map – для трансформации массива в массив.<br>
    reduce/reduceRight – для прохода по массиву с вычислением значения.`,
    ComplexityEnum.JUNIOR,
    SectionEnum.JS_CORE,
  ),
  new QuestionOld(
    'Опишите назначение и принципы работы с коллекциями Map и Set.',
    `Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа.
    <br><br>
    new Map() – создаёт коллекцию.<br>
    map.set(key, value) – записывает по ключу key значение value.<br>
    map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.<br>
    map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.<br>
    map.delete(key) – удаляет элемент по ключу key.<br>
    map.clear() – очищает коллекцию от всех элементов.<br>
    map.size – возвращает текущее количество элементов.<br><br>
    Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.
    <br><br>
    new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.<br>
    set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.<br>
    set.delete(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.<br>
    set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.<br>
    set.clear() – удаляет все имеющиеся значения.<br>
    set.size – возвращает количество элементов в множестве.<br>
    `,
    ComplexityEnum.JUNIOR,
    SectionEnum.JS_CORE,
  ),
  new QuestionOld(
    'Что означает глубокая (deep) и поверхностная (shallow) копия объекта? Как сделать каждую из них?',
    `При копировании объектов или массивов JavaScript копирует данные только на один уровень вглубь. Этот тип копирования называется поверхностным (shallow).

    Если необходимо полностью скопировать сложную структуру данных, например, массив с объектами, то нужно делать глубокое (deep) или полное копирование данных. JavaScript не содержит функций для глубокого копирования, лучший вариант сделать глубокую копию — сериализовать структуру в JSON и тут же распарсить.
    <br><br>
    Поверхностное копирование работает быстро и в большинстве случаев его достаточно. Проблемы появляются, когда приходится копировать вложенные структуры
    <br><br>
    Если изменять элементы этой структуры после копирования, то эти изменения будут также видны в исходной структуре`,
    ComplexityEnum.JUNIOR,
    SectionEnum.JS_CORE,
  ),
  new QuestionOld(
    'Какая разница между декларацией функции (function declaration) и функциональным выражением (function expression)',
    `Function Declaration - функция, объявленная в основном потоке кода.<br><br>
    Function Expression - объявление функции в контексте какого-либо выражения, например присваивания <br><br>
    Основное отличие между ними: функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода. <br><br>
    Поэтому их можно вызвать до объявления<br><br>
    Это из-за того, что JavaScript перед запуском кода ищет в нём Function Declaration (их легко найти: они не являются частью выражений и начинаются со словаfunction) и обрабатывает их. А Function Expression создаются в процессе выполнения выражения, в котором созданы<br><br>
    Function Expression можно (и даже нужно) использовать для условного объявления функции`,
    ComplexityEnum.JUNIOR,
    SectionEnum.FUNCTIONS,
  ),
  new QuestionOld(
    'Что такое анонимная функция?',
    `Прочитал в одной статье. Если после function есть имя — функция именованная, во всех остальных случая анонимная.
    var a = function() {} <br>
    a.name === 'a', потому что функцию можно рассматривать как объект со своими свойствами. К таким свойствам относится свойство name<br><br>
    стрелочные всегда анонимные<br><br>
    Нужна, если мы хотим вызвать функцию здесь и сейчас и больше нигде`,
    ComplexityEnum.JUNIOR,
    SectionEnum.FUNCTIONS,
  ),
  new QuestionOld(
    'Расскажите о стрелочных функциях (arrow function). В чем заключаются отличия стрелочных функций от обычных?',
    `Поведение this внутри стрелочной функции отличается от поведения this внутри обычной функции.Не имеет значения как она была вызвана, значение this внутри стрелочной функции всегда эквивалентно значения this внешней функции. Другими словами функция не создает собственный контекст исполнения, она использует внешний.<br><br>
    Как следствие того, что стрелочные функции не имеют собственного this они не могут быть использованы для создания объектов.Если ты попытаешься вызвать стрелочную функцию с использованием ключевого слова new, JS кинет исключение<br><br>
    Если return отсутствует внутри стрелочной функции, или после return нет выражения, функция вернет undefined<br><br>
    Если стрелочная функция содержит в теле одну инструкцию, и ты опустил фигурные скобки, тогда выражение будет возвращено автоматически`,
    ComplexityEnum.JUNIOR,
    SectionEnum.FUNCTIONS,
  ),
  new QuestionOld(
    'Что такое и для чего используют IIFE (Immediately Invoked Function Expression)?',
    `(function () {<br>
      statements<br>
  })();<br><br>
  IIFE (Immediately Invoked Function Expression) это JavaScript функция, которая выполняется сразу же после того, как она была определена.<br><br>
  Это тип выражений, также известный как Self-Executing Anonymous Function, который состоит из двух основных частей. Первая - это сама анонимная функция с лексической областью видимости, заключённым внутри Оператора группировки (). Благодаря этому переменные IIFE замыкаются в его пределах, и глобальная область видимости ими не засоряется.
  Вторая часть создаёт мгновенно выполняющееся функциональное выражение () , благодаря которому JavaScript-движок выполняет функцию напрямую.`,
    ComplexityEnum.JUNIOR,
    SectionEnum.FUNCTIONS,
  ),

  new QuestionOld(
    'Что такое hoisting, как он работает для переменных и функций?',
    `Механизм в JavaScript, в котором переменные и объявления функций, передвигаются вверх своей области видимости перед тем, как код будет выполнен.
    <br><br>
    Одним из преимуществ помещения в память объявлений функций до выполнения кода является возможность использовать функцию до её объявления
    <br><br>
    JavaScript "поднимает" только объявление, но не инициализацию<br>
    var x = 1; // Инициализируем x<br>
    console.log(x + " " + y);  // '1 undefined'<br>
    var y = 2;<br>
    //код выше и код ниже одинаковые<br><br>
    var x = 1; // Инициализируем x<br>
    var y; // Объявляем y<br>
    console.log(x + " " + y);  // '1 undefined'<br>
    y = 2; // Инициализируем y`,
    ComplexityEnum.JUNIOR,
    SectionEnum.FUNCTIONS,
  ),
  new QuestionOld(
    'Что такое замыкание (closure) и какие сценарии его использования?',
    `Замыкание это функция у которой есть доступ к своей внешней функции по области видимости, даже после того, как внешняя функция прекратилась. Это говорит о том, что замыкание может запоминать и получать доступ к переменным, и аргументам своей внешней функции, даже после того, как та прекратит выполнение.
    <br><br>
    function getCounter() {<br>
      let counter = 0;<br>
      return function() {<br>
        return counter++;<br>
      }<br>
    }<br>
    let count = getCounter();<br>
    console.log(count());  // 0<br>
    console.log(count());  // 1<br>
    console.log(count());  // 2`,
    ComplexityEnum.JUNIOR,
    SectionEnum.FUNCTIONS,
  ),
  new QuestionOld(
    'Что такое рекурсия?',
    `Рекурсия — это функция, которая вызывает саму себя<br>
    `,
    ComplexityEnum.JUNIOR,
    SectionEnum.FUNCTIONS,
  ),
  new QuestionOld(
    'Что означает ключевое слово this?',
    `Ключевое слово, которое содержит в себе объект (контекст) выполняемого кода <br>
    Если мы НЕ внутри функции, то this равен глобальному объекту<br>
    Если мы внутри стрелочной функции, то значение this такое же, как и функции на уровень выше<br>
    Если функция вызвана как конструктор (с помощью new), то this ссылается на новый объект, находящийся в процессе конструкции<br>
    Если функция создана с помощью метода bind, то значение this равняется значению первого аргумента, который мы передали в метод bind при создании данной функции<br>
    Если код выполняется в строгом режиме, то this равно undefined<br>
    Если функция передана куда-то в качестве колбэка или обработчика, то сложно сказать<br>
    Если функция вызвана с помощью метода apply или call, то this равно первому аргументу<br>
    Если  функция получена как значение свойства объекта и сразу же вызвана, то this равняется вышеупомянутому объекту<br>
    В остальных случаях this равен глобальному объекту`,
    ComplexityEnum.JUNIOR,
    SectionEnum.FUNCTIONS,
  ),
  new QuestionOld(
    'Что такое потеря контекста, когда происходит и как ее предотвратить?',
    `При передаче методов объекта в качестве колбэков, например для setTimeout, возникает известная проблема – потеря this.<br><br>
    Как только метод передаётся отдельно от объекта – this теряется.<br><br>
    Решение 1: сделать функцию-обёртку<br><br>
    Решение 2: привязать контекст с помощью bind`,
    ComplexityEnum.JUNIOR,
    SectionEnum.FUNCTIONS,
  ),
  new QuestionOld(
    'Методы функций bind / call / apply - зачем и в чем разница?',
    `Традиционно в JavaScript предоставляются объекты, обладающие собственными свойствами и методами. Например, object1 не может воспользоваться методами object2 и наоборот.
    <br><br>
    Вы можете задействовать методы call(), apply() и bind() для привязки функции к объекту и ее вызова, как если бы она принадлежала этому объекту.
    <br><br>
    Метод call() вызывает функцию с заданным контекстом. Иначе говоря, вы привязываете функцию к объекту, как если бы она ему принадлежала.
    <br><br>
    Метод apply() аналогичен call(). Отличие лишь в том, что call() принимает список аргументов, а apply() — массив.
    <br><br>
    Принцип действия метода bind() напоминает call() и apply(), но в отличие от них он возвращает функцию, выполнение которой может быть отложено.
    <br><br>
    var obj = { num: 2 };<br><br>

    function add(a, b){<br>
      return this.num + a + b;<br>
    }<br><br>

    const resultCall  = add.call(obj, 3, 5);<br>
    const resultApply = add.apply(obj, [3, 5]);<br>
    const funcBind    = add.bind(obj, 3, 5)<br>
    const resultBind  = funcBind();<br><br>

    console.log(resultCall, resultApply, resultBind);<br>
    10 10 10`,
    ComplexityEnum.JUNIOR,
    SectionEnum.FUNCTIONS,
  ),
  new QuestionOld(
    'Что такое DOM?',
    `DOM – это объектная модель документа, которую браузер создаёт в памяти компьютера на основании HTML-кода.<br><br>
    HTML-код – это текст страницы, а DOM – это объект, созданный браузером при парсинге этого текста.<br><br>
    Благодаря тому, что JavaScript позволяет изменять DOM, мы можем создавать динамические и интерактивные веб-приложения и сайты. С помощью JavaScript мы можем менять всё что есть на странице. Сейчас в вебе практически нет сайтов, в которых не используется работа с DOM.<br><br>
    `,
    ComplexityEnum.JUNIOR,
    SectionEnum.FRONT,
  ),
  new QuestionOld(
    'Сравните атрибуты подключения скрипта async и defer в HTML-документе.',
    `У async и defer есть кое-что общее: они не блокируют отрисовку страницы. Так что пользователь может просмотреть содержимое страницы и ознакомиться с ней сразу же<br><br>
    async: Порядок загрузки (кто загрузится первым, тот и сработает).<br>
    async, DOMContentLoaded: Не имеет значения. Может загрузиться и выполниться до того, как страница полностью загрузится. Такое случается, если скрипты маленькие или хранятся в кеше, а документ достаточно большой.<br>
    defer: Порядок документа (как расположены в документе).<br>
    defer, DOMContentLoaded: Выполняется после того, как документ загружен и обработан (ждёт), непосредственно перед DOMContentLoaded.`,
    ComplexityEnum.JUNIOR,
    SectionEnum.FRONT,
  ),
  new QuestionOld(
    'Какая разница между свойствами HTML-элементов innerHTML и innerText?',
    `innerText отобразит html тэги как строки<br>
    innerHTML извлекает весь контент вместе с тегами из указанного элемента на HTML странице.`,
    ComplexityEnum.JUNIOR,
    SectionEnum.FRONT,
  ),
  new QuestionOld(
    'Опишите процесс всплытия (bubbling) событий в DOM.',
    `После того, как событие сработает на самом вложенном элементе, оно также сработает на родителях, вверх по цепочке вложенности.<br><br>
    Остановить всплытие: event.stopPropagation(), Для IE<9 event.cancelBubble = true`,
    ComplexityEnum.JUNIOR,
    SectionEnum.FRONT,
  ),
  new QuestionOld(
    'Как остановить дефолтную обработку события?',
    `event.preventDefault()<br><br>
    Если же обработчик назначен через on<событие> (не через addEventListener), то также можно вернуть false из обработчика.`,
    ComplexityEnum.JUNIOR,
    SectionEnum.FRONT,
  ),
  new QuestionOld(
    'Чему равен this в обработчике событий (event handler)?',
    `Внутри обработчика события this ссылается на текущий элемент, то есть на тот, на котором, как говорят, «висит» (т.е. назначен) обработчик.<br>
    Кажется можно получить текущий элемент через element.target`,
    ComplexityEnum.JUNIOR,
    SectionEnum.FRONT,
  ),
  new QuestionOld(
    'Что такое LocalStorage и SessionStorage',
    `Объекты веб-хранилища localStorage и sessionStorage позволяют хранить пары ключ/значение в браузере.<br><br>
    Данные, которые в них записаны, сохраняются после обновления страницы (в случае sessionStorage) и даже после перезапуска браузера (при использовании localStorage)
    <br><br>
    В отличие от куки, объекты веб-хранилища не отправляются на сервер при каждом запросе. Именно поэтому мы можем хранить гораздо больше данных. Большинство современных браузеров могут выделить как минимум 5 мегабайтов данных (или больше), и этот размер можно поменять в настройках.
    <br><br>
    Ещё одно отличие от куки – сервер не может манипулировать объектами хранилища через HTTP-заголовки. Всё делается при помощи JavaScript.
    <br><br>
    Хранилище привязано к источнику (домен/протокол/порт). Это значит, что разные протоколы или поддомены определяют разные объекты хранилища, и они не могут получить доступ к данным друг друга.<br><br>
    key и value должны быть строками.
    <br>
    Лимит 5 Мб+, зависит от браузера.
    <br>
    Данные не имеют «времени истечения».
    `,
    ComplexityEnum.JUNIOR,
    SectionEnum.FRONT,
  ),
  new QuestionOld(
    'Как получить высоту блока? Его положение относительно границ документа?',
    ` document.getElementById('menu_bottom').clientHeight;<br>
    .getBoundingClientRect()`,
    ComplexityEnum.JUNIOR,
    SectionEnum.FRONT,
  ),
  new QuestionOld(
    'Что такое webpack?',
    `Вебпак — это сборщик модулей. Он анализирует модули приложения, создает граф зависимостей, затем собирает модули в правильном порядке в один или более бандл (bundle), на который может ссылаться файл «index.html».`,
    ComplexityEnum.JUNIOR,
    SectionEnum.FRONT,
  ),
  new QuestionOld(
    'Чем отличается dev-сборник от prod?',
    `Версия разработки - это рабочий вариант, черновик, грубо говоря, где на эстетику, безопасность, вид никакого внимания
    Продакшн - версия проекта для релиза, с соблюдением всех стандартов, мер безопасности и прочего. Продакшн - конечная версия продука
    `,
    ComplexityEnum.JUNIOR,
    SectionEnum.FRONT,
  ),
  new QuestionOld(
    'Что такое блочная модель CSS?',
    `Блочная модель — правила, по которым браузер определяет размер элемента на странице, его ширину и высоту.<br><br>
    padding, border, margin, width, height`,
    ComplexityEnum.JUNIOR,
    SectionEnum.LAYOUT,
  ),
  new QuestionOld(
    'Какие способы центрирования блочного контента по горизонтали и вертикали знаете?',
    `Блок по горизонтали центрируется margin: auto<br>
    Вертикальное же изначально не было предусмотрено в спецификации CSS и по сей день вызывает ряд проблем. 3 решения:<br>
    1. position:absolute + margin. Высота центрируемого элемента должна быть известна<br>
    2. Таблица с vertical-align <br>
    3. Центрирование в строке с vertical-align<br><br>
    Центрирование с использованием модели flexbox`,
    ComplexityEnum.JUNIOR,
    SectionEnum.LAYOUT,
  ),
  new QuestionOld(
    'Как сделать приложение responsive?',
    `Либо резиновый макет, либо медиа выражения<br>
    Я использую media выражения и mobile first`,
    ComplexityEnum.JUNIOR,
    SectionEnum.LAYOUT,
  ),
  new QuestionOld(
    'Какие есть принципы семантической верстки?',
    `Семантическая вёрстка — подход к разметке, который опирается не на содержание сайта, а на смысловое предназначение каждого блока и логическую структуру документа.
    <br><br>
    Чтобы сделать сайт доступным.<br>
    Чтобы сайт был выше в поисковиках<br>
    <article> <section> <aside> <nav> <header> <main>`,
    ComplexityEnum.JUNIOR,
    SectionEnum.LAYOUT,
  ),
  new QuestionOld(
    'Зачем нужны префиксы для некоторых CSS-свойств (-webkit-, -moz- и т. д.)?',
    `Все эти webkit, moz, ms, o — относятся к движкам отображения содержимого HTML и CSS. Например, параметр webkit отвечает за то, что данное свойство CSS будет работать именно в браузерах, которые использует этот движок.
    <br>
    Движок webkit используют одновременно два популярных браузера Chrome и Safari.
    Поэтому указав в свойствах -webkit оно будет понятно сразу обоим этим браузерам.<br>
    Надо сделать небольшую ремарку, что Google со своим Chrome, с определенной версии перешел с движка Webkit на Blink,
    который является ответвлением от Webkit.<br>
    -moz — Mozilla Firefox (движок Gecko)<br>
    Параметр -o – относится к Opera (раньше работал на движке Presto, сейчас на Blink)<br>
    -ms — это Microsoft Internet Explorer (использует движок Trident).<br><br>
    Последний раз использовал для input placeholder`,
    ComplexityEnum.JUNIOR,
    SectionEnum.LAYOUT,
  ),
  new QuestionOld(
    'Как упростить написание кросс-браузерных стилей?',
    `Используйте сброс или нормализацию стандартных стилей браузера. Reset.css или normalize.css<br><
    Используйте вендорные префиксы, где это необходимо<br><br>`,
    ComplexityEnum.JUNIOR,
    SectionEnum.LAYOUT,
  ),
  new QuestionOld(
    'Что такое CSS-препроцессоры? С какими работали? Что нового они приносят в стандартный CSS?',
    `CSS препроцессор это надстройка над CSS, которая добавляет ранее недоступные возможности для CSS, с помощью новых синтаксических конструкций.<br><br>
    В них есть переменные и миксины. Код лучше читается человеком. Есть вложенность`,
    ComplexityEnum.JUNIOR,
    SectionEnum.LAYOUT,
  ),
  new QuestionOld(
    'Перечислите основные компоненты фреймворка (модуль, роут, директива и т .п.).',
    `Компоненты, Модули, Формы, Сервисы, Директивы`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'В чем разница между компонентом и директивой?',
    `Если нужно вставить большой кусок HTML со своей логикой и функциональностью нужно использовать компонент, если нежно добавить только функциональность к уже существующим элементам, то – директивы.<br><br>
    На самом деле в документации angular написано, что в angular есть 3 типа директив. Структурные, директивы атрибутов и компоненты (директивы с шаблоном)`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Расскажите о жизненном цикле компонента.',
    `Каждый компонент имеет свой жизненный цикл (Component Lifecycle), в процессе которого вызываются ряд описывающих текущий этап методов (Angular Hooks)
    <br><br>
    OnChanges - устанавливаются или изменяются значения входных свойств класса компонента;
    <br>
    OnInit - устанавливаются "обычные" свойства; вызывается единожды вслед за первым вызовом OnChanges();
    <br>
    DoCheck - происходит изменения свойства или вызывается какое-либо событие;
    <br>
    AfterContentInit - в шаблон включается контент, заключенный между тегами компонента;
    <br>
    AfterContentChecked - аналогичен DoCheck(), только используется для контента, заключенного между тегами компонента;
    <br>
    AfterViewInit - инициализируются компоненты, которые входят в шаблон текущего компонента;
    <br>
    AfterViewChecked - аналогичен DoCheck(), только используется для дочерних компонентов;
    <br>
    OnDestroy - компонент "умирает", т. е. удаляется из DOM-дерева`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'В чем разница между конструктором и ngOnInit-хуком?',
    `конструктор - это свойство самого класса и не относится к категории Angular, поэтому Angular не имеет возможности управлять конструктором. Конструктор будет вызываться, когда класс генерирует экземпляр<br><br>
    ngOnInit является частью жизненного цикла Angular, он вызывается после завершения первого раунда ngOnChanges и вызывается только один раз<br>
    Несмотря на то, что Angular определяет ngOnInit, у конструктора есть свое место. Его основная функция - вводить зависимости.<br>
    ngOnInit предназначен исключительно для информирования разработчика о том, что компонент / инструкция был инициализирован, а операция привязки атрибута и операция ввода для компонента / инструкции завершены, что означает, что в функции ngOnInit мы Можно манипулировать данными, переданными в компоненте / инструкции`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Как защитить роут от несанкционированного доступа? Какие механизмы предоставляет для этого фреймворк?',
    `Guards позволяют ограничить навигацию по определенным маршрутам. Например, если для доступа к определенному ресурсу требуется наличие аутентификации или наличие каких-то других условий, в зависимости от которых мы можем предоставить пользователю доступ, а можем и не предоставить. То есть guards защищают доступ к ресурсу, собственно поэтому данные элементы и названы так: "guards", что с английского можно перевести как "защитники"<br><br>
    CanActivate представляет один из типов guards, который позволяет управлять доступом к ресурсу при маршрутизации.<br><br>
    CanDeactivate также позволяет управлять переходами. Он предназначен для таких, к примеру, случаев когда пользователь вводит какие-то данные. Однако не сохраняет их и покидает страницу. В этом случае мы могли бы выдать пользователю какое-либо предупреждение или окно с подтверждением перехода, чтобы избежать потери введенных данных.`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Что такое Lazy loading, как и для чего используется?',
    `Ленивая загрузка - это механизм, в результате которого некоторые составляющие загружаются только тогда, когда они нужны.
    Используется для уменьшения веса загружаемого кода, для оптимизации работы кода.<br><br>
    Для ленивой загрузки модулей используем свойство loadChildren, что означает, что модуль владельца с его компонентами не будет загружен, пока мы явно не запросим их<br><br>
    На одном из проектов я использую ленивую загрузку компонентов. <br>
    Создаю через ViewChild контейнер, в который можно добавить ленивый компонент<br>
    Далее я использую сущность ComponentFactoryResolver и его метод resolveComponentFactory() сервиса ComponentFactoryResolver,
    который принимает определение класса ComponentFactory и возвращает его экземпляр в виде ссылки типа ComponentRef.<br>
    После чего использую метод createComponent контейнера ViewContainerRef, передаю в метод ComponentRef и Injector.<br>
    Сама ленивая загрузка компонента происходит через команду import. Выражение иморта возвращает промис. Я использую async/await`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Какое назначение RouterOutlet?',
    `В файле RouterModule мы определяем маршруты и компоненты, которые будут обрабатывать указанные маршруты
    <br><br>
    Чтобы можно было внедрить в AppComponent тот компонент, который обрабатывает запрос,
    необходимо использовать элемент RouterOutlet На место элемента <router-outlet> будет рендериться компонент,
    выбранный для обработки запроса.`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Как компоненты могут взаимодействовать друг с другом?',
    `Input, Output, ViewChild, сервис с BehaviorSubject`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Как создать two-way binding свойство для компонента?',
    `@Component()<br>
    export class CustomCounterComponent {<br>
      counterValue = 0;<br>
      @Input()<br>
      get counter() {<br>
        return this.counterValue;<br>
      }<br>
      set counter(val) {<br>
        this.counterValue = val;<br>
        this.counterChange.emit(this.counterValue);<br>
      }<br><br>
      <custom-counter [(counter)]="someValue"></custom-counter><br>
      <p>counterValue = {{someValue}}</p>`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Какие типы форм у фреймворка? В каких случаях и что лучше использовать?',
    `Реактивные формы и формы на основе шаблонов.<br><br>
    На основе шаблонов через  [(ngModel)]="favoriteColor". Они полезны при создании в приложении простой формы, например, формы подписки на рассылку новостей.
    <br><br>
    По сравнению с формами на основе шаблонов, они более надежны: они масштабируемы, допускают повторное использование и хорошо тестируются. Если формы являются основной частью вашего приложения или вы уже используете реактивные шаблоны для создания приложения (реактивное программирование, rxjs), то используйте реактивные формы.`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Какие состояния у формы и как это можно применить?',
    `Если элемент ввода еще не получал фокус, то устанавливается класс ng-untouched. Если же поле ввода уже получало фокус, то к нему применяется класс ng-touched. При этом получение фокуса не обязательно должно сопровождаться изменением значения в этом поле.
    <br><br>
    Если первоначальное значение в поле ввода было изменено, то устанавливается класс ng-dirty. Если же значение не изменялось с момента загрузки страницы, то к элементу ввода применяется класс ng-pristine
    <br><br>
    Если значение в поле ввода корректно, то применяется класс ng-valid. Если же значение некорректно, то применяется класс ng-invalid`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Зачем нужны сервисы? Как с ними работать?',
    `Предоставление данных приложению. Сервис может сам хранить данные в памяти, либо для получения данных может обращаться к какому-нибудь источнику данных, например, к серверу.
    <br><br>
    Сервис может представлять канал взаимодействия между отдельными компонентами приложения
    <br><br>
    Сервис может инкапсулировать бизнес-логику, различные вычислительные задачи, задачи по логгированию, которые лучше выносить из компонентов. Тем самым код компонентов будет сосредоточен непосредственно на работе с представлением. Кроме того, тем самым мы также можем решить проблему повторения кода, если нам потребуется выполнить одну и ту же задачу в разных компонентах и классах
    <br><br>
    Сначала необходимо добавить сервис в массив providers родительского модуля, а после задействовать встроенный в Angular механизм dependency injection и получить объект сервиса в конструкторе компонента и затем использовать по необходимости`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    '',
    `Singleton  сервис является сервисом, для которого только один экземпляр существует в приложении.
    <br><br>
    Нужен для разделения некоторого ценного состояния между всеми частями вашего приложения.
    <br><br>
    providedIn: ‘root’ - способ сделать так, чтобы сервис не дублировался
    `,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Какие есть способы объявления сервисов?',
    `Если в сервис ничего не инжектируются, то просто export class Service. Если другие сервисы инжектируются в данный сервис, то нужен декоратор Injectable.
    Если необходимо сделать сервис не дублируемым, то необходимо декоратору Injectable добавить providedIn: ‘root’`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Для чего нужны модули? Сколько их должно быть в проекте?',
    `@NgModule определяет класс, как модуль Angular. Модули Angular помогают разбивать приложение на части (модули), которые взаимодействуют между собой и представляют в конечном итоге целостное приложение. Иными словами, модуль — это упаковка или инкапсуляция части функционала приложения. Модули можно проектировать с учетом многократного использования, т.е. не зависящие от конкретной реализации приложения.`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    ' Зачем нужны общие модули (shared)?',
    `Компоненты можно хранить в одном модуле, экспортируя их из него и импортируя его в те модули проекта, где эти компоненты могут понадобиться.
    <br><br>
    В такой модуль можно поместить компоненты кнопки, выпадающего списка, какого нибудь стилизованного блока текста и т.д, а также кастомные директивы и пайпы.`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Как предотвратить повторный импорт модулей и сервисов?',
    `Используйте хак с декораторами Optional и SkipSelf`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Какие преимущества типизации в TypeScript?',
    `TypeScript поддерживает статическую типизацию<br>
    TypeScript делает код проще для чтения и понимания<br>
    TypeScript помогает избежать множества болезненных багов, которые обычно совершают разработчики, благодаря проверке типов в коде<br>
    TypeScript поощряет разработчиков следовать лучшим ООП практикам`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Какие возможности TypeScript можно использовать для типизации?',
    `интерфейсы, типы, enum, явное преобразование`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Расскажите об обобщённых типах в TypeScript.',
    `Обобщённые типы (generics) позволяют создавать компоненты или функции, которые могут работать с различными типами, а не с каким-то одним. Рассмотрим пример:
    <br><br>
    /** Объявление класса с параметром обобщённого типа */<br>
class Queue<t> {<br>
  &nbsp;private data = [];<br>
  &nbsp;push = (item: T) => this.data.push(item);<br>
  &nbsp;pop = (): T => this.data.shift();<br>
}<br><br>

const queue = new Queue<number>();<br>
queue.push(0);<br>
queue.push("1"); // Ошибка : в такую очередь нельзя добавить строку`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Поддерживает ли TypeScript все принципы объектно-ориентированного программирования?',
    `Да, поддерживает. Существуют четыре основных принципа объектно-ориентированного программирования:
    <br><br>
    Инкапсуляция<br>
    Наследование<br>
    Абстракция<br>
    Полиморфизм<br><br>
    Пользуясь простыми и понятными средствами TypeScript, можно реализовать все эти принципы.`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Как в TypeScript реализовать свойства класса, являющиеся константами?',
    `В TypeScript 2.0 имеется модификатор readonly, позволяющий создавать свойства класса, предназначенные только для чтения`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Чем различаются ключевые слова interface и type в TypeScript?',
    `При использовании ключевого слова type вместо ключевого слова interface теряются следующие возможности:<br><br>
    Интерфейс может быть использован в выражении extends или implements, а псевдоним для литерала объектного типа — нет.<br><br>
    Интерфейс может иметь несколько объединённых объявлений, а при использовании ключевого слова type эта возможность не доступна.<br><br>
    type X = {a: number; b: string};<br>
    interface X {a: number; b: string}`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'В чем разница между интерфейсом и абстрактным классом?',
    `Абстрактный класс — это класс, у которого не реализован один или больше методов (некоторые языки требуют такие методы помечать специальными ключевыми словами).
    <br><br>
    Интерфейс — это абстрактный класс, у которого ни один метод не реализован, все они публичные и нет переменных класса.`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),

  new QuestionOld(
    'Какая разница между интерфейсом и классом?',
    `Класс - это объект, из которого мы можем создавать объекты с одинаковой конфигурацией - свойства и методы. Интерфейс - это группа связанных свойств и методов, которые описывают объект, но не обеспечивают их реализацию или инициализацию`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Чем отличаются Observable и Promise?',
    `Промис может обрабатывать лишь единственное значение. В дополнение к этому, промис нельзя отменить, что означает, что он вполне может заблокировать поток и впустую использовать ресурсы (важное соображение для маломощных устройств).`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Что такое RxJS? Как он используется во фреймворке? Какие компоненты фреймворка тесно связаны с ним?',
    `RxJS — это библиотека для JS, которая использует паттерн Observable (с англ. “Обозреваемый” / “Наблюдаемый”) для упрощения обработки и компановки асинхронного или callback кода.
    <br><br>
    Для использования библиотеки её необходимо установить, затем импортировать нужные классы и методы в компоненты и сервисы
    <br><br>
    Реактивные формы связаны с RxJS. Можно подписаться на valueChanges формы или отдельного форм контрола.
    Методы get, post, put, delete класса HttpClient возвращают потоки Observables`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Для чего нужны Subjects? Какие типы Subjects существуют?',
    `Тип Subject — разновидность RxJS Observable, который может доставлять данные сразу нескольким подписчикам.
    <br><br>
    BehaviorSubject — передает новому подписчику последнее значение, в качестве аргумента принимает начальное значение.
    <br><br>
    ReplaySubject — передает новому подписчику все предыдущие значения, принимаемый параметр — количество предыдущих значений.
    <br><br>
    AsyncSubject — передает новому подписчику последнее значение, но только после того, как будет вызван метод complete().`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Как сделать несколько последовательных запросов к API с помощью HTTP-сервиса и RxJS?',
    `switchMap, mergeMap, concatMap`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Какая разница между switchMap, concatMap, mergeMap?',
    `flatMap() разделяет rx-стрим на несколько промежуточных стримов, назовем их [A, B, C], и затем соединяет результат в один стрим. Элементы промежуточных стримов передаются напрямую в конечный стрим без гарантии сохранения порядка
    <br><br>
    concatMap() работает похожим на flatMap() образом, но сохраняет порядок промежуточных стримов
    <br><br>
    swithMap() кардинально отличается от FlatMap() и ConcatMap(). Он лучше всего подходит, если вы хотите проигнорировать промежуточные результаты и рассмотреть последний. SwitchMap отписывается от предыдущего источника Observable всякий раз, когда новый элемент начинает излучать данные, тем самым всегда эмитит данные из текущего Observable.
    <br><br>
    mergeMap() применяется, когда у вас есть Observable, элементы последовательности которого тоже Observable, а вам хочется объединить все в один поток (чтобы все элементы внутренние Observable порождали событие основного)`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    ' Зачем нужны environment-файлы? Когда их лучше не использовать?',
    `Я использую fileReplacements в angular.json для нужно среды. А в компонентах и сервисах вызываю просто ./environments/environment
    <br><br>.
    environment-файлы содержат переменные, которые изменяются в зависимости от среды`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'В чем разница между «умным» (smart) и «глупым» (dumb) компонентами? В каких случаях применяется каждый из них?',
    `Умные компоненты (контейнеры) управляют данными, реализуют бизнес-логику и обрабатывают события. Глупые (презентационные) компоненты принимают входные данные и могут генерировать события, обрабатывающиеся родительским умным компонентом. Глупые компоненты являются модульными и могут быть повторно использованы во всех приложениях из-за отсутствия у них состояния.`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'В чем разница между NgForm, FormGroup и FormControl и как их применяют для построения форм?',
    `Директива NgForm создает объект FormGroup и привязывает его к форме, что позволяет отслеживать состояние формы, управлять ее валидацией <form #myForm="ngForm">
    <br><br>
    FormControl — одиночный контрол формы;
    FormGroup — группа контролов формы;`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Зачем нужен и как работает async pipe?',
    `AsyncPipe позволяет получить результат асинхронной операции. AsyncPipe отслеживает объекты Observable и Promise и возвращает полученное из этих объектов значение
    <br><br>
    <p>Модель: {{ phone| async }}</p>
    <br><br>
    phone: Observable<string>|undefined;`,
    ComplexityEnum.JUNIOR,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    '',
    `Dependency Injection - широко распространенный паттерн проектирования (сокращенно DI), который позволяет создавать объект, использующий другие объекты. При этом изменения в определении используемых объектов никак не влияют на создаваемый объект.
    <br><br>
    Самый простой пример DI в Angular - это использованием компонентом сервиса, чаще всего для получения данных.
    <br><br>
    Для того чтобы созданный сервис мог быть использован компонентом или другим сервисом, его объявление должно предваряться декоратором @Injectable()
    <br><br>
    Для того чтобы сделать возможным внедрение в компонент сущность, не являющуюся сервисом Angular, нужно определить для нее вручную injection token.
    <br><br>
    Потом прописываем этот токен в массиве providers файла app.module {
      provide: DEFAULT_SETTINGS,
      useValue: { logging: true, requireAuth: false },
    },
    <br><br>
    В компоненте мы можем получить доступ к сущности DEFAULT_SETTINGS с помощью декоратора @Inject.`,
    ComplexityEnum.MIDDLE,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Что такое zone.js? Для чего Angular использует зоны? С какой целью можно использовать NgZone-сервис?',
    `Зона — это всего навсего механизм, просто имеет такое название, зоны позволяют нам отслеживать вызовы асинхронных функций.
    <br><br>
    Angular-разработчики в большом долгу перед библиотекой zone.js. Она, например, помогает достичь в работе с Angular почти волшебной лёгкости. На самом деле, практически всегда, когда нужно просто поменять какое-нибудь свойство, и мы меняем его, ни о чём не задумываясь, Angular производит повторный рендеринг соответствующих компонентов. В результате то, что видит пользователь, всегда содержит самую свежую информацию.
    <br><br>
    Наиболее популярный способ использования NgZone-сервиса должен оптимизировать производительность при запуске работы, состоящей из одной или нескольких асинхронных задач, которые не требуют, чтобы обновления UI или обработка ошибок были обработаны Angular. Такие задачи могут быть начаты через runOutsideAngular и в случае необходимости, эти задачи могут повторно войти в зону Angular через run.`,
    ComplexityEnum.MIDDLE,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Как работает Change detection? Как можно оптимизировать компонент с помощью схем Change detection? Какие еще есть приемы для оптимизации рендеринга (связанные с Change detection)?',
    `Механизм обнаружения изменений в Angular отвечает за придание компоненту динамичности. Во время цикла обнаружения изменений Angular ищет все привязки, повторно выполняет всё выражение, сравнивает его с предыдущими значениями и, если изменение обнаружено, распространяет его на элементы DOM.
    <br><br>
    Обнаружение изменений в Angular выполняется, когда:
    <br>
    1. Имеют место обновления переменной состояния в Angular.<br>
    2. Внутри компонента Angular вызываются события.<br>
    3. Обновляются значения @Input для компонентов.<br><br>
    Если стратегия компонента не настраивается, она обозначается как стратегия «Default». Стратегия обнаружения «Default» применяется к компоненту во время его создания. В этой стратегии цикл обнаружения изменений выполняется для каждого отдельного события, происходящего внутри компонента.
    <br>
    1. Событие нажатия на элементы.<br>
    2. Получение данных через асинхронный вызов.<br>
    3. Запуск setTimeout и setInterval.<br><br>
    Стратегия обнаружения изменений «onPush». Согласно этой стратегии, дочерний компонент ChildComponent не всегда проверяется на изменение данных. Такая проверка не должна проводиться, если родительский элемент обновляет значения, которые не передаются дочернему компоненту в свойствах @Input.
    <br><br>
    Ещё Методы: Отключение детектора изменений, Обнаружение локальных изменений, Запуск вне Angular через ngZone.runOutsideAngular, `,
    ComplexityEnum.MIDDLE,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Как выполнить конфигурацию HTTP-сервиса? Зачем она нужна? Обработка HTTP-ошибок?',
    `Объявить для каждого запроса на сервер отдельный метод. При необходимости дополнительно преобразовать входные данные. Методы возвращают Observable
    <br><br>
    Конфигурация нужна для удобства работы, для обращения к методам сервиса из различных компонентов
    <br><br>
    Для универсального обработчика ошибок необходимо создать сервис ApiErrorsInterceptor implements HttpInterceptor, затем описать сервис в провайдерах app.module<br>
     {<br>
      provide: HTTP_INTERCEPTORS,<br>
      useClass: ApiErrorsInterceptor,<br>
      multi: true,<br>
    }<br><br>
    В качестве обработчика используется метод catchError из rxjs/operators`,
    ComplexityEnum.MIDDLE,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Какие есть подходы к организации работы с данными?',
    `Использование сервисов для взаимодействия с сервером. Использование фабрик для создания необходимых моделей на основе json файлов, приходящих с сервиса.
    <br><br>
    Если необходимо небольшое хранилище данных, то подойдёт использование сервиса с BehaviorSubject и методами обновления этого сабджекта.
    Тогда мы сможем подписываться из различных компонентов и всегда иметь в компонентах актуальные данные
    <br><br>
    Если данных для хранения становится много, то можно перейти на использование библиотеки NgRx`,
    ComplexityEnum.MIDDLE,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Как подготовить сборник к деплою?',
    `1. Выполнить установку npm install
    <br>
     2. Собрать исходные файлы: ng build --prod
    <br>
    3. Скопировать сгенерированные файлы из директории dist в корневую папку web-сервера.`,
    ComplexityEnum.MIDDLE,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Что такое NgRx? Когда стоит использовать?',
    `NGRX — angular/rxjs версией Redux шаблона<br>
    Таким образом, по общему мнению, ngrx следует использовать в средних/больших проектах, когда управление состоянием начинает становиться сложным в обслуживании
    <br><br>
    !!Лучше выучить схему ngrx и посмотреть другие примеры!!`,
    ComplexityEnum.MIDDLE,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'В каких случаях лучше использовать Renderer-сервис вместо нативных методов? И наоборот?',
    `Вместо прямой работы с DOM-элементом через nativeElement Angular предоставляет нам следующие абстракции — Renderer, TemplateRef, ElementRef и ViewContainerRef
    <br><br>
    Renderer используется в основном для манипуляций над уже существующими элементами, например для изменения стилей элемента, атрибутов и параметров элемента. Наиболее часто его использование можно встретить при создании директив. Но он также позволяет создавать новые элементы и вставлять их в DOM
    <br><br>
    Класс Renderer2 — это абстракция, предоставляемая Angular в виде службы, которая позволяет манипулировать элементами вашего приложения, не касаясь напрямую DOM. Это рекомендуемый подход, потому что он упрощает разработку приложений, которые можно отображать в средах, не имеющих доступа к DOM, например на сервере или на мобильном устройстве.
    <br><br>
    !!Разберись с директивами, используй на практике!!`,
    ComplexityEnum.MIDDLE,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Как работают и для чего нужны резолверы? Как получить данные, загруженные резолверами?',
    `Резолверы в Angular используются для предварительной выборки данных: пока пользователь перенаправляется с одного маршрута на другой, новая доступная страница уже будет содержать те данные, которые требуется на ней отобразить.
    <br><br>
    1. Импортировать интерфейс «Resolve» из «@angular/router».<br>
    2. Создать класс сервиса, реализующий этот интерфейс «Resolve».<br>
    3. Переопределить функцию «resolve()», указав HTTP-запрос, который нужно ждать. Эта функция может вернуть Promise или Observable.<br>
    4. Добавить этот класс сервиса в корневой модуль «root».<br>
    5. Добавить в компонент «ActivatedRouteSnapshot», который загружается для использования данных, доступных из AJAX-запроса, указанного в функции «resolve».
    <br><br>
    !!используй на практике!!`,
    ComplexityEnum.MIDDLE,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Как работают и зачем нужны динамические компоненты? Приведите примеры их целесообразного использования.',
    `В Angular динамическая компиляция компонентов реализована через сервис ComponentFactoryResolver.
    <br><br>
    Для отображения такого компонента сперва необходимо определить место, где он будет располагаться. Местом служит ссылка на представление типа ViewContainerRef.
    <br><br>
    Реальный пример. Я использую динамические компоненты в одном из своих ангуляр проектов.
    В этом проекте проводятся АБ тесты. Разные юзеры, заходя на сайт, могут увидеть различные варианты отображения.
    Разницы в отображаемых экранах. Каждый экран - это отдельный компонент. Всегда в проекте около 40 типов различных экранов.
    Пользователь заходит на один роут и видит загрузку. В это время фронт отправляет на бэк запрос для получения варианта.
    Получив вариант фронт выбирает информацию о первом отображаемом экране. В зависимости от типа экрана необходимо отобразить компонент
    В родительском шаблоне есть контейнеры <ng-template #currentContainer></ng-template> и <ng-template #nextContainer></ng-template>
    В родительском компоненте работа с контейнерами производится через декоратор @ViewChild
    Когда фронт определяет тип экрана, то он передаёт этот тип экрана в метод специального сервиса-фабрики.
    Метод возвращает Promise<ComponentFactory>.
    Для определения того, какой компонент необходимо лениво загрузить используется обычный switch case по типу
    Компонент загружается через await import(путь)
    После загрузки компонент передаётся в метод resolveComponentFactory класса ComponentFactoryResolver.
    Результат работы этого метода resolveComponentFactory мы и возвращаем из нашего метода специального сервиса
    Затем в компоненте для нашего ViewContainerRef мы вызываем метод createComponent и передаём туда то, что вернул специальный метод, то есть ComponentFactory.
    К специальному методу обращаемся через await, так как он возвращает Promise.
    Кроме ComponentFactory мы передаём в метод createComponent ещё и Injector.
    Результат работы метода createComponent записываем в переменную instance. При помощи этой переменной мы сообщаем компоненту данные, принимаемые им через @Input и подписываемся на события декоратора @Output`,
    ComplexityEnum.MIDDLE,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Какая разница между @ViewChild и @ContentChild?',
    `Шаблонные переменные позволяют определить некоторые переменные внутри шаблона компонента и затем ссылаться к этим переменным из этого же шаблона.
    <br><br>
    !!Сложна. View Child - внутренние дети, а ContentChild - внешние дети!!`,
    ComplexityEnum.MIDDLE,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Что делает код и как ещё можно связать класс компонента с переменной? @HostBinding ( "class.valid") isValid;',
    `!!Сложна!!`,
    ComplexityEnum.MIDDLE,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    ' Как можно кэшировать данные, используя сервисы или RxJS?',
    `publishReplay(1) - буфер в одно сообщение. Каждый новый подписчик получит последний результат.<br>
    refCount() - автоматически вызывет методы connect(), если появляются подписчки и unsubscribe(), когда подписчиков не остаётся.<br><br>
    private _cache: Observable<WhateverResponse>;<br>
    getData(): Observable<WhateverResponse> {<br>
      if (!this._cache) {<br>
          this._cache = this._http.get('url').pipe(<br>
              publishReplay(1),<br>
              refCount()<br>
          );<br>
      }<br>
      return this._cache;<br>
  }  `,
    ComplexityEnum.MIDDLE,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Что такое асинхронная валидация форм? Когда применяется и как реализуется?',
    `Использование механизма асинхронной валидации (Angular async validators)
    позволяет проверять введенное значение на удаленном сервере.
    Например, проверка уникальности имени пользователя при регистрации или проверка существования email.
    <br><br>
    !!Нужно использовать на практике!!`,
    ComplexityEnum.MIDDLE,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Зачем нужна forRoot-функция модуля?',
    `Частая проблема в Angular при ленивой загрузке модулей в том, что к глобальному инжектору добавляется новый инжектор
    <br><br>
    Для того, чтобы сервисы точно были зафиксированы в глобальном инжекторе, модуль с провайдерами импортируется только в AppModule. Со стороны импортируемого модуля нужно лишь создать статический метод, возвращающий ModuleWithProviders, который исторически получил название forRoot.
    <br>
    Механизм разрешающий зависимости и создающий сущности
    <br><br>
    Инжектор - объект в системе Angular, который может найти зависимость по ключу в своем кеше или создать зависимость с использованием настроенного провайдера (Provider). Инжекторы создаются для NgModules автоматически как часть процесса начальной загрузки и наследуются через иерархию компонентов.`,
    ComplexityEnum.MIDDLE,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Какая разница между декларированием и экспортом компонента из модуля?',
    `declarations: классы представлений (view classes), которые принадлежат модулю. Angular имеет три типа классов представлений: компоненты (components), директивы (directives), каналы (pipes)
    <br><br>
    exports: набор классов представлений, которые должны использоваться в шаблонах компонентов из других модулей`,
    ComplexityEnum.MIDDLE,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Почему плохо «провайдить» сервис с shared-модуля в lazy-loaded модуль? (Вопрос о scope модулей.)',
    `Видимо создасться новый эксземпляр такого сервиса`,
    ComplexityEnum.MIDDLE,
    SectionEnum.ANGULAR,
  ),
  new QuestionOld(
    'Что такое :: ng-deep и для чего используется?',
    `Инструмент, позволяет точечно отключать инкапсуляцию у селектора
    <br><br>
    ViewEncapsulation.Emulated (по умолчанию) Данный тип изолирует стили компонента от остальных путем добавления к селекторам стилей уникального атрибута компонента. Соответствующий атрибут добавляется ко всем элементам компонента.
    <br><br>
    ViewEncapsulation.None Данный тип отключает инкапсуляцию у компонента. На элементы не вешаются атрибуты, к селекторам не добавляются атрибуты
    <br><br>
    ViewEncapsulation.ShadowDom Данный тип реализует честную инкапсуляцию через ShadowDOM. По документации рекомендуется применять только для библиотек. Но есть нюансы.`,
    ComplexityEnum.MIDDLE,
    SectionEnum.ANGULAR,
  ),
];
